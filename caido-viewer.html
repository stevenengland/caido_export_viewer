<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Caido Export Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #1a1a1a;
        color: #e0e0e0;
        line-height: 1.4;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #4a9eff;
        margin-bottom: 10px;
      }

      .upload-area {
        border: 2px dashed #444;
        border-radius: 8px;
        padding: 40px;
        text-align: center;
        margin-bottom: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upload-area:hover {
        border-color: #4a9eff;
        background: rgba(74, 158, 255, 0.05);
      }

      .upload-area.dragover {
        border-color: #4a9eff;
        background: rgba(74, 158, 255, 0.1);
      }

      .file-input {
        display: none;
      }

      .requests-table {
        width: 100%;
        border-collapse: collapse;
        background: #2a2a2a;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 20px;
        table-layout: fixed;
      }

      .requests-table th,
      .requests-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #444;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .requests-table th {
        background: #333;
        font-weight: 600;
        color: #ccc;
        position: relative;
        user-select: none;
      }

      .col-resizer {
        position: absolute;
        right: 0;
        top: 0;
        width: 6px;
        height: 100%;
        cursor: col-resize;
        z-index: 2;
        background: transparent;
        transition: background 0.2s;
      }

      .col-resizer:hover {
        background: #4a9eff44;
      }

      .requests-table tbody tr {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .requests-table tbody tr:hover {
        background: #3a3a3a;
      }

      .requests-table tbody tr.selected {
        background: #4a9eff20;
      }

      .method {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }

      .method.GET {
        background: #28a745;
      }
      .method.POST {
        background: #ffc107;
        color: #000;
      }
      .method.PUT {
        background: #17a2b8;
      }
      .method.DELETE {
        background: #dc3545;
      }

      .status {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }

      .status.success {
        background: #28a745;
      }
      .status.error {
        background: #dc3545;
      }
      .status.redirect {
        background: #ffc107;
        color: #000;
      }

      .details-panel {
        display: none;
        background: #2a2a2a;
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
      }

      .details-panel.active {
        display: block;
      }

      .details-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
      }

      .details-section {
        background: #1a1a1a;
        border-radius: 8px;
        padding: 20px;
      }

      .details-section h2 {
        color: #4a9eff;
        margin-bottom: 20px;
        font-size: 1.5em;
        border-bottom: 2px solid #444;
        padding-bottom: 10px;
      }

      .details-section h3 {
        color: #ccc;
        margin: 20px 0 10px 0;
        font-size: 1.1em;
      }

      .code-block {
        background: #1a1a1a;
        border: 1px solid #444;
        border-radius: 4px;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .info-grid {
        display: grid;
        grid-template-columns: 150px 1fr;
        gap: 10px;
        margin-bottom: 20px;
      }

      .info-label {
        font-weight: bold;
        color: #aaa;
      }

      .info-value {
        color: #e0e0e0;
      }

      .hidden {
        display: none;
      }

      .error {
        background: #dc3545;
        color: white;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }

      /* Fix scrollable requests table to fill width */
      .scrollable-requests-wrapper {
        max-height: 480px;
        overflow-y: auto;
        width: 100%;
      }
      .scrollable-requests {
        /* Remove display:block, let it be default */
      }
      .scrollable-requests tr {
        /* Remove display:table, let it be default */
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Caido Export Viewer</h1>
        <p>Upload your Caido export JSON file to analyze HTTP requests</p>
      </div>

      <div class="upload-area" id="uploadArea">
        <p>Drop your Caido export JSON file here or click to select</p>
        <input type="file" id="fileInput" class="file-input" accept=".json" />
      </div>

      <div id="errorMessage" class="error hidden"></div>

      <div id="requestsContainer" class="hidden">
        <table class="requests-table" id="mainRequestsTable">
          <colgroup>
            <col style="width: 7%" />
            <col style="width: 10%" />
            <col style="width: 18%" />
            <col style="width: 25%" />
            <col style="width: 10%" />
            <col style="width: 15%" />
            <col style="width: 15%" />
          </colgroup>
          <thead>
            <tr>
              <th>
                ID
                <div class="col-resizer"></div>
              </th>
              <th>
                Method
                <div class="col-resizer"></div>
              </th>
              <th>
                Host
                <div class="col-resizer"></div>
              </th>
              <th>
                Path
                <div class="col-resizer"></div>
              </th>
              <th>
                Status
                <div class="col-resizer"></div>
              </th>
              <th>
                Response Time
                <div class="col-resizer"></div>
              </th>
              <th>
                Length
                <div class="col-resizer"></div>
              </th>
            </tr>
          </thead>
        </table>
        <div id="requestsTableBodyWrapper">
          <table
            class="requests-table"
            style="border-top: none; table-layout: fixed; width: 100%"
          >
            <colgroup>
              <col style="width: 7%" />
              <col style="width: 10%" />
              <col style="width: 18%" />
              <col style="width: 25%" />
              <col style="width: 10%" />
              <col style="width: 15%" />
              <col style="width: 15%" />
            </colgroup>
            <tbody id="requestsTableBody"></tbody>
          </table>
        </div>
      </div>

      <div id="detailsPanel" class="details-panel">
        <div class="details-container">
          <div class="details-section">
            <h2>Request</h2>
            <div class="info-grid" id="requestInfo"></div>
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                margin-top: 20px;
              "
            >
              <h3 style="margin: 0">Request Headers</h3>
              <button
                class="copy-btn"
                id="copyRequestHeadersBtn"
                title="Copy headers to clipboard"
              >
                ðŸ“‹
              </button>
            </div>
            <div class="code-block" id="requestHeaders"></div>
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                margin-top: 20px;
              "
            >
              <h3 style="margin: 0">Request Body</h3>
              <button
                class="copy-btn"
                id="copyRequestBodyBtn"
                title="Copy body to clipboard"
              >
                ðŸ“‹
              </button>
            </div>
            <div class="code-block" id="requestBody"></div>
          </div>

          <div class="details-section">
            <h2>Response</h2>
            <div class="info-grid" id="responseInfo"></div>
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                margin-top: 20px;
              "
            >
              <h3 style="margin: 0">Response Headers</h3>
              <button
                class="copy-btn"
                id="copyResponseHeadersBtn"
                title="Copy headers to clipboard"
              >
                ðŸ“‹
              </button>
            </div>
            <div class="code-block" id="responseHeaders"></div>
            <div
              style="
                display: flex;
                align-items: center;
                gap: 10px;
                margin-top: 20px;
              "
            >
              <h3 style="margin: 0">Response Body</h3>
              <button
                class="copy-btn"
                id="copyResponseBodyBtn"
                title="Copy body to clipboard"
              >
                ðŸ“‹
              </button>
            </div>
            <div class="code-block" id="responseBody"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      let requests = [];
      let selectedRequest = null;

      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");
      const errorMessage = document.getElementById("errorMessage");
      const requestsContainer = document.getElementById("requestsContainer");
      const requestsTableBody = document.getElementById("requestsTableBody");
      const detailsPanel = document.getElementById("detailsPanel");

      // File upload handlers
      uploadArea.addEventListener("click", () => fileInput.click());
      uploadArea.addEventListener("dragover", handleDragOver);
      uploadArea.addEventListener("drop", handleDrop);
      uploadArea.addEventListener("dragleave", handleDragLeave);
      fileInput.addEventListener("change", handleFileSelect);

      function handleDragOver(e) {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      }

      function handleDragLeave(e) {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
      }

      function handleDrop(e) {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          processFile(files[0]);
        }
      }

      function handleFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
          processFile(files[0]);
        }
      }

      function processFile(file) {
        if (!file.name.endsWith(".json")) {
          showError("Please select a JSON file");
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);
            if (Array.isArray(data)) {
              requests = data;
              displayRequests();
              hideError();
            } else {
              showError("Invalid JSON format. Expected an array of requests.");
            }
          } catch (error) {
            showError("Error parsing JSON file: " + error.message);
          }
        };
        reader.readAsText(file);
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.remove("hidden");
      }

      function hideError() {
        errorMessage.classList.add("hidden");
      }

      function displayRequests() {
        requestsTableBody.innerHTML = "";

        // Toggle scrollable class if more than 10 entries
        const wrapper = document.getElementById("requestsTableBodyWrapper");
        if (requests.length > 10) {
          requestsTableBody.classList.add("scrollable-requests");
          if (wrapper) wrapper.classList.add("scrollable-requests-wrapper");
        } else {
          requestsTableBody.classList.remove("scrollable-requests");
          if (wrapper) wrapper.classList.remove("scrollable-requests-wrapper");
        }

        requests.forEach((request, index) => {
          const row = document.createElement("tr");

          // ID
          const tdId = document.createElement("td");
          tdId.textContent = request.id || index;
          row.appendChild(tdId);

          // Method
          const tdMethod = document.createElement("td");
          const methodSpan = document.createElement("span");
          methodSpan.className = "method " + (request.method || "");
          methodSpan.textContent = request.method || "";
          tdMethod.appendChild(methodSpan);
          row.appendChild(tdMethod);

          // Host
          const tdHost = document.createElement("td");
          tdHost.textContent = request.host || "";
          row.appendChild(tdHost);

          // Path
          const tdPath = document.createElement("td");
          tdPath.textContent = request.path || "";
          row.appendChild(tdPath);

          // Status
          const tdStatus = document.createElement("td");
          const statusSpan = document.createElement("span");
          const statusCode = request.response && request.response.status_code;
          statusSpan.className = "status " + getStatusClass(statusCode);
          statusSpan.textContent = statusCode || "N/A";
          tdStatus.appendChild(statusSpan);
          row.appendChild(tdStatus);

          // Response Time
          const tdRespTime = document.createElement("td");
          tdRespTime.textContent = formatResponseTime(
            request.response && request.response.length
          );
          tdRespTime.appendChild(document.createTextNode(" ms"));
          row.appendChild(tdRespTime);

          // Length
          const tdLength = document.createElement("td");
          tdLength.textContent = request.length || "N/A";
          row.appendChild(tdLength);

          row.addEventListener("click", () => selectRequest(index, row));
          requestsTableBody.appendChild(row);
        });

        requestsContainer.classList.remove("hidden");
      }

      function getStatusClass(status) {
        if (!status) return "";
        if (status >= 200 && status < 300) return "success";
        if (status >= 300 && status < 400) return "redirect";
        if (status >= 400) return "error";
        return "";
      }

      function formatResponseTime(time) {
        return time ? time.toString() : "N/A";
      }

      function selectRequest(index, rowElement) {
        // Remove previous selection
        document.querySelectorAll(".requests-table tbody tr").forEach((row) => {
          row.classList.remove("selected");
        });

        // Add selection to current row
        rowElement.classList.add("selected");

        selectedRequest = requests[index];
        displayRequestDetails();
        detailsPanel.classList.add("active");
      }

      function displayRequestDetails() {
        if (!selectedRequest) return;

        // Request info
        const requestInfo = document.getElementById("requestInfo");
        requestInfo.innerHTML = `
                <div class="info-label">Method:</div>
                <div class="info-value">${selectedRequest.method}</div>
                <div class="info-label">Host:</div>
                <div class="info-value">${selectedRequest.host}:${
          selectedRequest.port
        }</div>
                <div class="info-label">Path:</div>
                <div class="info-value">${selectedRequest.path}</div>
                <div class="info-label">TLS:</div>
                <div class="info-value">${
                  selectedRequest.is_tls ? "Yes" : "No"
                }</div>
                <div class="info-label">Length:</div>
                <div class="info-value">${selectedRequest.length} bytes</div>
            `;

        // Response info
        const responseInfo = document.getElementById("responseInfo");
        if (selectedRequest.response) {
          responseInfo.innerHTML = `
                    <div class="info-label">Status:</div>
                    <div class="info-value">${selectedRequest.response.status_code}</div>
                    <div class="info-label">Length:</div>
                    <div class="info-value">${selectedRequest.response.length} bytes</div>
                `;
        } else {
          responseInfo.innerHTML =
            '<div class="info-value">No response data available</div>';
        }

        // Headers and Bodies
        updateHeadersAndBodies();

        // Setup copy buttons
        setTimeout(() => {
          const copyRequestHeadersBtn = document.getElementById(
            "copyRequestHeadersBtn"
          );
          const copyRequestBodyBtn =
            document.getElementById("copyRequestBodyBtn");
          const copyResponseHeadersBtn = document.getElementById(
            "copyResponseHeadersBtn"
          );
          const copyResponseBodyBtn = document.getElementById(
            "copyResponseBodyBtn"
          );
          const requestHeaders = document.getElementById("requestHeaders");
          const requestBody = document.getElementById("requestBody");
          const responseHeaders = document.getElementById("responseHeaders");
          const responseBody = document.getElementById("responseBody");

          if (copyRequestHeadersBtn)
            copyRequestHeadersBtn.onclick = () =>
              copyToClipboard(requestHeaders.textContent);
          if (copyRequestBodyBtn)
            copyRequestBodyBtn.onclick = () =>
              copyToClipboard(requestBody.textContent);
          if (copyResponseHeadersBtn)
            copyResponseHeadersBtn.onclick = () =>
              copyToClipboard(responseHeaders.textContent);
          if (copyResponseBodyBtn)
            copyResponseBodyBtn.onclick = () =>
              copyToClipboard(responseBody.textContent);
        }, 0);
      }

      function prettifyContent(content, headers = "") {
        if (!content || content.trim() === "") {
          return content;
        }

        // Try to detect content type from headers
        const contentType = headers.toLowerCase();

        // Try JSON formatting
        if (
          contentType.includes("application/json") ||
          contentType.includes("text/json") ||
          content.trim().startsWith("{") ||
          content.trim().startsWith("[")
        ) {
          try {
            const parsed = JSON.parse(content);
            return JSON.stringify(parsed, null, 2);
          } catch (e) {
            // Not valid JSON, continue to other formats
          }
        }

        // Try XML formatting
        if (
          contentType.includes("application/xml") ||
          contentType.includes("text/xml") ||
          content.trim().startsWith("<?xml") ||
          content.trim().startsWith("<")
        ) {
          try {
            return formatXML(content);
          } catch (e) {
            // Not valid XML, return original
          }
        }

        // For URL-encoded data
        if (contentType.includes("application/x-www-form-urlencoded")) {
          try {
            const params = new URLSearchParams(content);
            const formatted = [];
            for (const [key, value] of params) {
              formatted.push(`${key} = ${value}`);
            }
            return formatted.join("\n");
          } catch (e) {
            // Return original if parsing fails
          }
        }

        return content;
      }

      function formatXML(xml) {
        const PADDING = "  ";
        const reg = /(>)(<)(\/*)/g;
        let formatted = xml.replace(reg, "$1\r\n$2$3");
        let pad = 0;

        return formatted
          .split("\r\n")
          .map((line) => {
            let indent = 0;
            if (line.match(/.+<\/\w[^>]*>$/)) {
              indent = 0;
            } else if (line.match(/^<\/\w/) && pad > 0) {
              pad -= 1;
            } else if (line.match(/^<\w[^>]*[^\/]>.*$/)) {
              indent = 1;
            } else {
              indent = 0;
            }

            const padding = PADDING.repeat(pad);
            pad += indent;
            return padding + line;
          })
          .join("\r\n");
      }

      function updateHeadersAndBodies() {
        const requestHeaders = document.getElementById("requestHeaders");
        const responseHeaders = document.getElementById("responseHeaders");
        const requestBody = document.getElementById("requestBody");
        const responseBody = document.getElementById("responseBody");

        // Parse request headers and body from raw data
        if (selectedRequest.raw) {
          try {
            const decodedRequest = atob(selectedRequest.raw);
            const headerEnd = decodedRequest.indexOf("\r\n\r\n");
            if (headerEnd !== -1) {
              const headerSection = decodedRequest.substring(0, headerEnd);
              const bodySection = decodedRequest.substring(headerEnd + 4);

              requestHeaders.textContent = headerSection;
              requestBody.textContent = bodySection
                ? prettifyContent(bodySection, headerSection)
                : "No request body";
            } else {
              requestHeaders.textContent = "Could not parse request headers";
              requestBody.textContent = "Could not parse request body";
            }
          } catch (e) {
            requestHeaders.textContent = "Error parsing request headers";
            requestBody.textContent = "Error parsing request body";
          }
        } else {
          requestHeaders.textContent = "Request headers not available";
          requestBody.textContent = "Request body not available";
        }

        // Parse response headers and body from raw data
        if (selectedRequest.response && selectedRequest.response.raw) {
          try {
            const decodedResponse = atob(selectedRequest.response.raw);
            const headerEnd = decodedResponse.indexOf("\r\n\r\n");
            if (headerEnd !== -1) {
              const headerSection = decodedResponse.substring(0, headerEnd);
              const bodySection = decodedResponse.substring(headerEnd + 4);

              responseHeaders.textContent = headerSection;
              // Try to prettify and detect if it's JSON
              let prettified = bodySection
                ? prettifyContent(bodySection, headerSection)
                : "No response body";
              responseBody.textContent = prettified;

              // Add JSON node parsing button if JSON
              const responseBodyParent = responseBody.parentElement;
              let parseBtn = responseBodyParent.querySelector(
                ".parse-json-nodes-btn"
              );
              if (parseBtn) parseBtn.remove();
              let isJson = false;
              try {
                const contentType = headerSection.toLowerCase();
                if (
                  contentType.includes("application/json") ||
                  contentType.includes("text/json") ||
                  (bodySection &&
                    (bodySection.trim().startsWith("{") ||
                      bodySection.trim().startsWith("[")))
                ) {
                  JSON.parse(bodySection);
                  isJson = true;
                }
              } catch {}
              if (isJson) {
                parseBtn = document.createElement("button");
                parseBtn.textContent = "Parse stringified JSON nodes";
                parseBtn.className = "parse-json-nodes-btn";
                parseBtn.style =
                  "margin-bottom:10px;display:block;background:#222;color:#4a9eff;border:none;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;";
                responseBodyParent.insertBefore(parseBtn, responseBody);
                parseBtn.onclick = function () {
                  try {
                    let obj = JSON.parse(bodySection);
                    obj = parseStringifiedJsonNodes(obj);
                    responseBody.textContent = JSON.stringify(obj, null, 2);
                  } catch (e) {
                    responseBody.textContent =
                      "Error parsing stringified JSON nodes.";
                  }
                };
              }
              // Recursively parse stringified JSON nodes in an object/array
              function parseStringifiedJsonNodes(obj) {
                if (typeof obj === "string") {
                  try {
                    const parsed = JSON.parse(obj);
                    // Only parse if the result is an object or array
                    if (typeof parsed === "object" && parsed !== null) {
                      return parseStringifiedJsonNodes(parsed);
                    }
                  } catch {}
                  return obj;
                } else if (Array.isArray(obj)) {
                  return obj.map(parseStringifiedJsonNodes);
                } else if (typeof obj === "object" && obj !== null) {
                  const result = {};
                  for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                      result[key] = parseStringifiedJsonNodes(obj[key]);
                    }
                  }
                  return result;
                }
                return obj;
              }
            } else {
              responseHeaders.textContent = "Could not parse response headers";
              responseBody.textContent = "Could not parse response body";
            }
          } catch (e) {
            responseHeaders.textContent = "Error parsing response headers";
            responseBody.textContent = "Error parsing response body";
          }
        } else {
          responseHeaders.textContent = "Response headers not available";
          responseBody.textContent = "Response body not available";
        }
      }

      function copyToClipboard(text) {
        if (navigator.clipboard) {
          navigator.clipboard.writeText(text);
        } else {
          // fallback for older browsers
          const textarea = document.createElement("textarea");
          textarea.value = text;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
        }
      }

      // --- Column resizing logic ---
      function setupColumnResizing() {
        const mainTable = document.getElementById("mainRequestsTable");
        if (!mainTable) return;
        const colgroup = mainTable.querySelector("colgroup");
        const resizers = mainTable.querySelectorAll(".col-resizer");
        let startX, startWidth, col, colIdx;

        resizers.forEach((resizer, idx) => {
          resizer.onmousedown = function (e) {
            e.preventDefault();
            startX = e.pageX;
            col = colgroup.children[idx];
            startWidth = col.offsetWidth;
            colIdx = idx;
            document.body.style.cursor = "col-resize";
            document.onmousemove = onMouseMove;
            document.onmouseup = onMouseUp;
          };
        });

        function onMouseMove(e) {
          if (!col) return;
          let diff = e.pageX - startX;
          let newWidth = Math.max(40, startWidth + diff);
          col.style.width = newWidth + "px";
          // Set width for body colgroup as well
          const bodyColgroup = document.querySelector(
            "#requestsTableBodyWrapper colgroup"
          );
          if (bodyColgroup && bodyColgroup.children[colIdx]) {
            bodyColgroup.children[colIdx].style.width = newWidth + "px";
          }
        }
        function onMouseUp() {
          document.body.style.cursor = "";
          document.onmousemove = null;
          document.onmouseup = null;
          col = null;
        }
      }
      // Call after DOMContentLoaded
      document.addEventListener("DOMContentLoaded", setupColumnResizing);
    </script>
  </body>
</html>
