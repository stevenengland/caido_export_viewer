<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Caido Export Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #1a1a1a;
        color: #e0e0e0;
        line-height: 1.4;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #4a9eff;
        margin-bottom: 10px;
      }

      .upload-area {
        border: 2px dashed #444;
        border-radius: 8px;
        padding: 40px;
        text-align: center;
        margin-bottom: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upload-area:hover {
        border-color: #4a9eff;
        background: rgba(74, 158, 255, 0.05);
      }

      .upload-area.dragover {
        border-color: #4a9eff;
        background: rgba(74, 158, 255, 0.1);
      }

      .file-input {
        display: none;
      }

      .requests-table {
        width: 100%;
        border-collapse: collapse;
        background: #2a2a2a;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .requests-table th,
      .requests-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #444;
      }

      .requests-table th {
        background: #333;
        font-weight: 600;
        color: #ccc;
      }

      .requests-table tbody tr {
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .requests-table tbody tr:hover {
        background: #3a3a3a;
      }

      .requests-table tbody tr.selected {
        background: #4a9eff20;
      }

      .method {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }

      .method.GET {
        background: #28a745;
      }
      .method.POST {
        background: #ffc107;
        color: #000;
      }
      .method.PUT {
        background: #17a2b8;
      }
      .method.DELETE {
        background: #dc3545;
      }

      .status {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }

      .status.success {
        background: #28a745;
      }
      .status.error {
        background: #dc3545;
      }
      .status.redirect {
        background: #ffc107;
        color: #000;
      }

      .details-panel {
        display: none;
        background: #2a2a2a;
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
      }

      .details-panel.active {
        display: block;
      }

      .details-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
      }

      .details-section {
        background: #1a1a1a;
        border-radius: 8px;
        padding: 20px;
      }

      .details-section h2 {
        color: #4a9eff;
        margin-bottom: 20px;
        font-size: 1.5em;
        border-bottom: 2px solid #444;
        padding-bottom: 10px;
      }

      .details-section h3 {
        color: #ccc;
        margin: 20px 0 10px 0;
        font-size: 1.1em;
      }

      .code-block {
        background: #1a1a1a;
        border: 1px solid #444;
        border-radius: 4px;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .info-grid {
        display: grid;
        grid-template-columns: 150px 1fr;
        gap: 10px;
        margin-bottom: 20px;
      }

      .info-label {
        font-weight: bold;
        color: #aaa;
      }

      .info-value {
        color: #e0e0e0;
      }

      .hidden {
        display: none;
      }

      .error {
        background: #dc3545;
        color: white;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Caido Export Viewer</h1>
        <p>Upload your Caido export JSON file to analyze HTTP requests</p>
      </div>

      <div class="upload-area" id="uploadArea">
        <p>Drop your Caido export JSON file here or click to select</p>
        <input type="file" id="fileInput" class="file-input" accept=".json" />
      </div>

      <div id="errorMessage" class="error hidden"></div>

      <div id="requestsContainer" class="hidden">
        <table class="requests-table">
          <thead>
            <tr>
              <th>ID</th>
              <th>Method</th>
              <th>Host</th>
              <th>Path</th>
              <th>Status</th>
              <th>Response Time</th>
              <th>Length</th>
            </tr>
          </thead>
          <tbody id="requestsTableBody"></tbody>
        </table>
      </div>

      <div id="detailsPanel" class="details-panel">
        <div class="details-container">
          <div class="details-section">
            <h2>Request</h2>
            <div class="info-grid" id="requestInfo"></div>
            <h3>Request Headers</h3>
            <div class="code-block" id="requestHeaders"></div>
            <h3>Request Body</h3>
            <div class="code-block" id="requestBody"></div>
          </div>

          <div class="details-section">
            <h2>Response</h2>
            <div class="info-grid" id="responseInfo"></div>
            <h3>Response Headers</h3>
            <div class="code-block" id="responseHeaders"></div>
            <h3>Response Body</h3>
            <div class="code-block" id="responseBody"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      let requests = [];
      let selectedRequest = null;

      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");
      const errorMessage = document.getElementById("errorMessage");
      const requestsContainer = document.getElementById("requestsContainer");
      const requestsTableBody = document.getElementById("requestsTableBody");
      const detailsPanel = document.getElementById("detailsPanel");

      // File upload handlers
      uploadArea.addEventListener("click", () => fileInput.click());
      uploadArea.addEventListener("dragover", handleDragOver);
      uploadArea.addEventListener("drop", handleDrop);
      uploadArea.addEventListener("dragleave", handleDragLeave);
      fileInput.addEventListener("change", handleFileSelect);

      function handleDragOver(e) {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      }

      function handleDragLeave(e) {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
      }

      function handleDrop(e) {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          processFile(files[0]);
        }
      }

      function handleFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
          processFile(files[0]);
        }
      }

      function processFile(file) {
        if (!file.name.endsWith(".json")) {
          showError("Please select a JSON file");
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);
            if (Array.isArray(data)) {
              requests = data;
              displayRequests();
              hideError();
            } else {
              showError("Invalid JSON format. Expected an array of requests.");
            }
          } catch (error) {
            showError("Error parsing JSON file: " + error.message);
          }
        };
        reader.readAsText(file);
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.remove("hidden");
      }

      function hideError() {
        errorMessage.classList.add("hidden");
      }

      function displayRequests() {
        requestsTableBody.innerHTML = "";

        requests.forEach((request, index) => {
          const row = document.createElement("tr");
          row.innerHTML = `
                    <td>${request.id || index}</td>
                    <td><span class="method ${request.method}">${
            request.method
          }</span></td>
                    <td>${request.host}</td>
                    <td>${request.path}</td>
                    <td><span class="status ${getStatusClass(
                      request.response?.status_code
                    )}">${request.response?.status_code || "N/A"}</span></td>
                    <td>${formatResponseTime(request.response?.length)} ms</td>
                    <td>${request.length || "N/A"}</td>
                `;

          row.addEventListener("click", () => selectRequest(index, row));
          requestsTableBody.appendChild(row);
        });

        requestsContainer.classList.remove("hidden");
      }

      function getStatusClass(status) {
        if (!status) return "";
        if (status >= 200 && status < 300) return "success";
        if (status >= 300 && status < 400) return "redirect";
        if (status >= 400) return "error";
        return "";
      }

      function formatResponseTime(time) {
        return time ? time.toString() : "N/A";
      }

      function selectRequest(index, rowElement) {
        // Remove previous selection
        document.querySelectorAll(".requests-table tbody tr").forEach((row) => {
          row.classList.remove("selected");
        });

        // Add selection to current row
        rowElement.classList.add("selected");

        selectedRequest = requests[index];
        displayRequestDetails();
        detailsPanel.classList.add("active");
      }

      function displayRequestDetails() {
        if (!selectedRequest) return;

        // Request info
        const requestInfo = document.getElementById("requestInfo");
        requestInfo.innerHTML = `
                <div class="info-label">Method:</div>
                <div class="info-value">${selectedRequest.method}</div>
                <div class="info-label">Host:</div>
                <div class="info-value">${selectedRequest.host}:${
          selectedRequest.port
        }</div>
                <div class="info-label">Path:</div>
                <div class="info-value">${selectedRequest.path}</div>
                <div class="info-label">TLS:</div>
                <div class="info-value">${
                  selectedRequest.is_tls ? "Yes" : "No"
                }</div>
                <div class="info-label">Length:</div>
                <div class="info-value">${selectedRequest.length} bytes</div>
            `;

        // Response info
        const responseInfo = document.getElementById("responseInfo");
        if (selectedRequest.response) {
          responseInfo.innerHTML = `
                    <div class="info-label">Status:</div>
                    <div class="info-value">${selectedRequest.response.status_code}</div>
                    <div class="info-label">Length:</div>
                    <div class="info-value">${selectedRequest.response.length} bytes</div>
                `;
        } else {
          responseInfo.innerHTML =
            '<div class="info-value">No response data available</div>';
        }

        // Headers and Bodies
        updateHeadersAndBodies();
      }

      function prettifyContent(content, headers = "") {
        if (!content || content.trim() === "") {
          return content;
        }

        // Try to detect content type from headers
        const contentType = headers.toLowerCase();

        // Try JSON formatting
        if (
          contentType.includes("application/json") ||
          contentType.includes("text/json") ||
          content.trim().startsWith("{") ||
          content.trim().startsWith("[")
        ) {
          try {
            const parsed = JSON.parse(content);
            return JSON.stringify(parsed, null, 2);
          } catch (e) {
            // Not valid JSON, continue to other formats
          }
        }

        // Try XML formatting
        if (
          contentType.includes("application/xml") ||
          contentType.includes("text/xml") ||
          content.trim().startsWith("<?xml") ||
          content.trim().startsWith("<")
        ) {
          try {
            return formatXML(content);
          } catch (e) {
            // Not valid XML, return original
          }
        }

        // For URL-encoded data
        if (contentType.includes("application/x-www-form-urlencoded")) {
          try {
            const params = new URLSearchParams(content);
            const formatted = [];
            for (const [key, value] of params) {
              formatted.push(`${key} = ${value}`);
            }
            return formatted.join("\n");
          } catch (e) {
            // Return original if parsing fails
          }
        }

        return content;
      }

      function formatXML(xml) {
        const PADDING = "  ";
        const reg = /(>)(<)(\/*)/g;
        let formatted = xml.replace(reg, "$1\r\n$2$3");
        let pad = 0;

        return formatted
          .split("\r\n")
          .map((line) => {
            let indent = 0;
            if (line.match(/.+<\/\w[^>]*>$/)) {
              indent = 0;
            } else if (line.match(/^<\/\w/) && pad > 0) {
              pad -= 1;
            } else if (line.match(/^<\w[^>]*[^\/]>.*$/)) {
              indent = 1;
            } else {
              indent = 0;
            }

            const padding = PADDING.repeat(pad);
            pad += indent;
            return padding + line;
          })
          .join("\r\n");
      }

      function updateHeadersAndBodies() {
        const requestHeaders = document.getElementById("requestHeaders");
        const responseHeaders = document.getElementById("responseHeaders");
        const requestBody = document.getElementById("requestBody");
        const responseBody = document.getElementById("responseBody");

        // Parse request headers and body from raw data
        if (selectedRequest.raw) {
          try {
            const decodedRequest = atob(selectedRequest.raw);
            const headerEnd = decodedRequest.indexOf("\r\n\r\n");
            if (headerEnd !== -1) {
              const headerSection = decodedRequest.substring(0, headerEnd);
              const bodySection = decodedRequest.substring(headerEnd + 4);

              requestHeaders.textContent = headerSection;
              requestBody.textContent = bodySection
                ? prettifyContent(bodySection, headerSection)
                : "No request body";
            } else {
              requestHeaders.textContent = "Could not parse request headers";
              requestBody.textContent = "Could not parse request body";
            }
          } catch (e) {
            requestHeaders.textContent = "Error parsing request headers";
            requestBody.textContent = "Error parsing request body";
          }
        } else {
          requestHeaders.textContent = "Request headers not available";
          requestBody.textContent = "Request body not available";
        }

        // Parse response headers and body from raw data
        if (selectedRequest.response && selectedRequest.response.raw) {
          try {
            const decodedResponse = atob(selectedRequest.response.raw);
            const headerEnd = decodedResponse.indexOf("\r\n\r\n");
            if (headerEnd !== -1) {
              const headerSection = decodedResponse.substring(0, headerEnd);
              const bodySection = decodedResponse.substring(headerEnd + 4);

              responseHeaders.textContent = headerSection;
              // Try to prettify and detect if it's JSON
              let prettified = bodySection
                ? prettifyContent(bodySection, headerSection)
                : "No response body";
              responseBody.textContent = prettified;

              // Add JSON node parsing button if JSON
              const responseBodyParent = responseBody.parentElement;
              let parseBtn = responseBodyParent.querySelector(
                ".parse-json-nodes-btn"
              );
              if (parseBtn) parseBtn.remove();
              let isJson = false;
              try {
                const contentType = headerSection.toLowerCase();
                if (
                  contentType.includes("application/json") ||
                  contentType.includes("text/json") ||
                  (bodySection &&
                    (bodySection.trim().startsWith("{") ||
                      bodySection.trim().startsWith("[")))
                ) {
                  JSON.parse(bodySection);
                  isJson = true;
                }
              } catch {}
              if (isJson) {
                parseBtn = document.createElement("button");
                parseBtn.textContent = "Parse stringified JSON nodes";
                parseBtn.className = "parse-json-nodes-btn";
                parseBtn.style =
                  "margin-bottom:10px;display:block;background:#222;color:#4a9eff;border:none;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;";
                responseBodyParent.insertBefore(parseBtn, responseBody);
                parseBtn.onclick = function () {
                  try {
                    let obj = JSON.parse(bodySection);
                    obj = parseStringifiedJsonNodes(obj);
                    responseBody.textContent = JSON.stringify(obj, null, 2);
                  } catch (e) {
                    responseBody.textContent =
                      "Error parsing stringified JSON nodes.";
                  }
                };
              }
              // Recursively parse stringified JSON nodes in an object/array
              function parseStringifiedJsonNodes(obj) {
                if (typeof obj === "string") {
                  try {
                    const parsed = JSON.parse(obj);
                    // Only parse if the result is an object or array
                    if (typeof parsed === "object" && parsed !== null) {
                      return parseStringifiedJsonNodes(parsed);
                    }
                  } catch {}
                  return obj;
                } else if (Array.isArray(obj)) {
                  return obj.map(parseStringifiedJsonNodes);
                } else if (typeof obj === "object" && obj !== null) {
                  const result = {};
                  for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                      result[key] = parseStringifiedJsonNodes(obj[key]);
                    }
                  }
                  return result;
                }
                return obj;
              }
            } else {
              responseHeaders.textContent = "Could not parse response headers";
              responseBody.textContent = "Could not parse response body";
            }
          } catch (e) {
            responseHeaders.textContent = "Error parsing response headers";
            responseBody.textContent = "Error parsing response body";
          }
        } else {
          responseHeaders.textContent = "Response headers not available";
          responseBody.textContent = "Response body not available";
        }
      }
    </script>
  </body>
</html>
